![medusavshydradvwa](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/blob/main/Desafio_DVWA/images/medusahydradvwa.png)

üü¢ FINALIZADO - Atividades conclu√≠das e revisadas (Entregue antes do prazo)  

> [!Important]
> - Sucesso no Brute Force com Hydra ap√≥s perceber que a Medusa n√£o consegue lidar com CSRF.  
> - O n√≠vel do DVWA estava no `Impossible`
> - Foi modificado um dos scripts do DVWA (login.php), comentando uma linha expec√≠ficia que valida os tokens de seguran√ßa CSRF


# Desafio: Simulando um Ataque de Brute Force com Medusa e An√°lise de Prote√ß√µes CSRF

**Desafio Santander Ciberseguran√ßa 2025 em parceria com a DIO**
>[!TIP]
> - O script Python para automa√ß√£o de tentativas em formul√°rio web (DVWA n√≠vel low) est√° aqui: [Redirect Brute Forcer](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/blob/main/Desafio_DVWA/redirect_brute_forcer.py)
> - O Desafio de ataque em FTP do Metasploitable 2 est√° aqui: [Desafio Brute Force Ataque FTP Metasploitable](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/tree/main/Desafio%20de%20For%C3%A7a%20Bruta%20em%20FTP%20do%20Metasploitable%202)

## √çndice
1. [Vis√£o Geral do Projeto](#1-vis√£o-geral-do-projeto)[.](#tutorial-r√°pido-e-secreto-n√≠vel-impossible-ou-qualquer-outro)
2. [Configura√ß√£o do Ambiente](#2-configura√ß√£o-do-ambiente)
3. [An√°lise Inicial com cURL](#3-an√°lise-inicial-com-curl)
4. [Entendendo o CSRF na Pr√°tica](#4-entendendo-o-csrf-na-pr√°tica)
5. [Testes com Medusa](#5-testes-com-medusa)
6. [An√°lise do C√≥digo-Fonte](#6-an√°lise-do-c√≥digo-fonte)
7. [Resultados](#7-resultados-antes-e-depois-de-entender-como-desativar-a-valida√ß√£o-do-csrf)
8. [An√°lise Detalhada](#8-an√°lise-detalhada-dos-resultados)
9. [Conclus√µes T√©cnicas](#9-conclus√µes-t√©cnicas)
10. [Li√ß√µes Aprendidas como Profissional de Seguran√ßa](#10-li√ß√µes-aprendidas-como-profissional-de-seguran√ßa)
11. [Recomenda√ß√µes de Mitiga√ß√£o](#11-recomenda√ß√µes-de-mitiga√ß√£o)
12. [Pr√≥ximos Passos e Expans√£o](#12-pr√≥ximos-passos-e-expans√£o)
13. [Conclus√£o Final](#13-conclus√£o-final)
14. [About Me](#14-about-me--contact)

## 1. Vis√£o Geral do Projeto

### Objetivo Principal
Este projeto teve como objetivo principal entender na pr√°tica como mecanismos de seguran√ßa modernos, especificamente prote√ß√µes CSRF (Cross-Site Request Forgery), impactam a efic√°cia de ferramentas automatizadas de brute force. Como profissional de seguran√ßa em constante evolu√ß√£o, busquei ir al√©m do uso superficial de ferramentas e compreender os porqu√™s por tr√°s dos sucessos e falhas.

### Metodologia Adotada
Adotei uma abordagem cient√≠fica para o projeto:
- **An√°lise**: Estudo detalhado do alvo antes de qualquer ataque
- **Experimenta√ß√£o**: Testes controlados com diferentes ferramentas
- **Documenta√ß√£o**: Registro detalhado de cada etapa e resultado
- **An√°lise**: Interpreta√ß√£o dos resultados e extra√ß√£o de aprendizado

### Ferramentas Utilizadas
- **Kali Linux**: Sistema operacional para testes de seguran√ßa
- **DVWA (Damn Vulnerable Web Application)**: Alvo controlado para testes
- **Medusa**: Ferramenta de brute force
- **Hydra**: Alternativa para compara√ß√£o
- **cURL**: Ferramenta essencial para an√°lise manual
- **GitHub**: Plataforma para documenta√ß√£o e portf√≥lio

## 2. Configura√ß√£o do Ambiente

### Download, Configura√ß√£o e Insta√ß√£o do Kali e Metasploitable 2 na VirtualBox  

  Para essa parte fiz um outro reposit√≥rio para ajudar os outros estudantes a entenderem:  
  
  - Quais sites encontrar as ferramentas (VirtualBox, Kali Linux e Metasploitable) utilizdas nesse projeto  
  - Como fazer o download e configurar o Kali Linux e a Metasploitable na VirtualBox  
  - Dicas para resolver problemas simples de configura√ß√£o  

Esse √© o link do reposit√≥rio com os v√≠deos [Laborat√≥rio Kali Linux & Metasploitable](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/tree/main/security-training-lab)

### Instala√ß√£o do DVWA  

Existem outros jeito de utilizar o DVWA que n√£o seja fazendo o download do Metasploitable 2.  
A partir daqui, todos os testes do DVWA foram feitos com a vers√£o instalada pelo terminal do Kali Linux e n√£o a vers√£o que vem com o Metasploitable.  
Lembrando que:

- Estou com o Kali Linux instalado na VirtualBox somente para esse desafio (n√£o utilizei essa m√°quina virtual antes).
- A internet foi utilizada somente para o download do DVWA pelo terminal.
- A rede da m√°quina virtual com Kali foi mudada para "host only" antes de iniciar o DVWA.
- A m√°quina virtual com Kali n√£o estava compartilhando arquivos com o host (meu computador de lab de seguran√ßa).
- A m√°quina virtual com Kali foi deletada ap√≥s o esse desafio.

 >[!Tip]
 >- Voc√™ pode utilizar o DVWA online em sites como o TryHackMe, HackTheBox e VulnHub

- Voc√™ pode utilizar a vers√£o que preferir, pois √© a mesma ferramenta    


 > [!CAUTION]  
 > N√£o instale o DVWA na sua m√°quina do dia-a-dia, independe da distro Linux que voc√™ utiliza  
 > **Existem riscos significativos** em instalar o DVWA diretamente no Linux que voc√™ utiliza no dia-a-dia como:
 >  - Configura√ß√µes de seguran√ßa podem ser comprometidas
 >  - Arquivos de configura√ß√£o podem ser alterados/acidentais
 >  - Exposi√ß√£o acidental √† internet se servi√ßos n√£o forem configurados corretamente
 >  - Vulnerabilidades reais no DVWA podem afetar seu sistema principal
 >  - Risco de backdoors se n√£o isolado adequadamente
 >  - Conflito de vers√µes (PHP, Apache, MySQL)
 >  - Portas em uso (80, 443, 3306 podem j√° estar ocupadas)



- Algumas configura√ß√µes para outros cen√°rios podem ser diferentes dessas:
  
```bash
# Atualiza√ß√£o do sistema
sudo apt update

# Instala√ß√£o do DVWA
sudo apt install dvwa

# Inicializa√ß√£o do servi√ßo
dvwa-start
```

**Observa√ß√£o** (Desligue a internet): O comando `dvwa-start` faz automaticamente:
- Inicia os servi√ßos necess√°rios (Apache, MySQL)
- Configura o banco de dados
- Abre o navegador padr√£o no endere√ßo `http://127.0.0.1:42001/login.php`

### Configura√ß√£o Inicial do DVWA

Ap√≥s a instala√ß√£o, foi necess√°rio:
1. **Login inicial** com credenciais padr√£o: `admin`/`password`
2. **Configura√ß√£o do banco de dados** atrav√©s do script de setup
3. **Ajuste do n√≠vel de seguran√ßa** para "Low" para testes iniciais

### Estrutura do Ambiente

```
VirtualBox (Virtualiza√ß√£o dos Ambientes)
    ‚Üì
Kali Linux (Atacante)
    ‚Üì
DVWA (127.0.0.1:42001) (Alvo)
    ‚Üì
Formul√°rio de Login (/login.php)
    ‚Üì
Mecanismo CSRF (Prote√ß√£o)
```

## 3. An√°lise Inicial com cURL

### Primeira Investiga√ß√£o

Comecei com uma an√°lise b√°sica do formul√°rio de login do DVWA:

```bash
# Comando b√°sico para visualizar o HTML do formul√°rio
curl http://127.0.0.1:42001/login.php -s

# Filtrando apenas elementos relevantes
curl http://127.0.0.1:42001/login.php -s | grep -E "username|password|token|submit"
```

**Resultado Esperado:**
```html
<input type="text" class="loginInput" size="20" name="username">
<input type="password" class="loginInput" size="20" name="password">
<input type="submit" value="Login" name="Login">
<input type='hidden' name='user_token' value='8afba5f0f1431a381e5698f891e1eac3' />
```

### An√°lise Detalhada dos Elementos

**Campos Identificados:**
1. **username**: Campo de texto para nome de usu√°rio
2. **password**: Campo de senha
3. **Login**: Bot√£o de submiss√£o (com name attribute)
4. **user_token**: Campo hidden com token CSRF

### Testes Manuais de Login

**Teste com Credenciais Corretas:**
```bash
curl -X POST http://127.0.0.1:42001/login.php \
  -d "username=admin&password=password&Login=Login" \
  -c cookies.txt -L -v
```

**Teste com Credenciais Incorretas:**
```bash
curl -X POST http://127.0.0.1:42001/login.php \
  -d "username=admin&password=wrongpassword&Login=Login" \
  -s | grep "Login failed"
```

### An√°lise de Headers e Cookies

```bash
# Verificando headers de resposta
curl -I http://127.0.0.1:42001/login.php

# Analisando cookies de sess√£o
curl http://127.0.0.1:42001/login.php -c cookies.txt -v
```

**Descoberta Importante**: Cada requisi√ß√£o gerava um novo token CSRF, mesmo dentro da mesma sess√£o.

## 4. Entendendo o CSRF na Pr√°tica

### O Que √© CSRF?

CSRF (Cross-Site Request Forgery) √© um mecanismo de seguran√ßa que:
- **Gera tokens √∫nicos** para cada formul√°rio
- **Vincula tokens √† sess√£o** do usu√°rio
- **Valida a origem** das requisi√ß√µes
- **Previne ataques automatizados** que n√£o mant√™m estado

### Como Funciona no DVWA

**Fluxo Normal:**
1. Usu√°rio acessa `/login.php`
2. Servidor gera token √∫nico `ABC123` e armazena na sess√£o
3. Token √© enviado no formul√°rio como campo hidden
4. Ao submeter, servidor compara token do form com token da sess√£o
5. Se coincidirem: login processado
6. Se divergirem: login bloqueado

**Fluxo com Ataque Automatizado:**
1. Ferramenta acessa `/login.php` e recebe token `ABC123`
2. Ferramenta tenta login, mas o token j√° expirou
3. Servidor gera novo token `DEF456` para pr√≥xima requisi√ß√£o
4. Ferramenta continua usando token antigo `ABC123`
5. Todas as tentativas falham por token inv√°lido

### Testes com Diferentes Abordagens

**Teste 1 - Token Est√°tico:**
```bash
# Tentativa com token fixo 
curl -X POST http://127.0.0.1:42001/login.php \
  -d "username=admin&password=password&Login=Login&user_token=123456" \
  -s -w "Status: %{http_code}\n"
```

**Teste 2 - Sem Token:**
```bash
# Tentativa sem token 
curl -X POST http://127.0.0.1:42001/login.php \
  -d "username=admin&password=password&Login=Login" \
  -s -w "Status: %{http_code}\n"
```

**Teste 3 - Token Din√¢mico:**
```bash
# Extraindo token dinamicamente
TOKEN=$(curl http://127.0.0.1:42001/login.php -s | grep -o "user_token' value='[^']*" | cut -d"'" -f3)
curl -X POST http://127.0.0.1:42001/login.php \
  -d "username=admin&password=password&Login=Login&user_token=$TOKEN" \
  -c cookies.txt -L -v
```

### An√°lise de Comportamento

**Padr√µes Identificados:**
- **Status 302 + Location: login.php** ‚Üí Falha de autentica√ß√£o
- **Status 302 + Location: index.php** ‚Üí Login bem-sucedido
- **Status 200 com "Login failed"** ‚Üí Credenciais incorretas
- **Status 200 sem redirecionamento** ‚Üí Token CSRF inv√°lido

---

## 5. Testes com Medusa

### Prepara√ß√£o para os Testes

#### Cria√ß√£o das Wordlists

Antes de iniciar os testes com Medusa, preparei wordlists espec√≠ficas e realistas:

**usernames.txt:**
```bash
administrator
root2
admin
root
admin2
test
user
username
```

**passwords.txt:**
```bash
admin
123456
letmein
password
default
test
pass123
```

**Justificativa das Wordlists:**
- **Usernames**: Inclu√≠ varia√ß√µes comuns de "admin" e usu√°rios padr√£o
- **Passwords**: Senhas comuns e default do DVWA ("password")
- **Tamanho controlado**: Para testes r√°pidos e eficientes

#### Comando Base do Medusa

```bash
medusa -h 127.0.0.1 -U usernames.txt -P passwords.txt -M web-form \
  -m FORM:"/login.php" \
  -m DENY-SIGNAL:"Login failed" \
  -m FORM-DATA:"post?username=&password=&Login=Login" \
  -n 42001 \
  -v 4
```

### Primeira Tentativa - Falha Imediata

**Comando Executado:**
```bash
medusa -h 127.0.0.1 -U usernames.txt -P passwords.txt -M web-form \
  -m FORM:"/login.php" \
  -m DENY-SIGNAL:"Login failed" \
  -m FORM-DATA:"post?username=&password=&Login=Login" \
  -v 4
```

**Resultado:**
```
Medusa v2.3 [http://www.foofus.net] (C) JoMo-Kun / Foofus Networks <jmk@foofus.net>

NOTICE: web-form.mod: failed to connect, port 443 was not open on 127.0.0.1
```

**An√°lise do Erro:**
- Medusa tentou usar HTTPS (porta 443) por padr√£o
- DVWA estava rodando em HTTP na porta 42001
- Necessidade de ajuste na sintaxe

### Segunda Tentativa - Corre√ß√£o de Porta

**Comando Corrigido:**
```bash
medusa -h 127.0.0.1 -U usernames.txt -P passwords.txt -M web-form \
  -m FORM:"/login.php" \
  -m DENY-SIGNAL:"Login failed" \
  -m FORM-DATA:"post?username=&password=&Login=Login" \
  -n 42001 \
  -v 4
```

**Resultado:**
```
ACCOUNT CHECK: [web-form] Host: 127.0.0.1 User: administrator Password: admin
ERROR: The answer was NOT successfully received, understood, and accepted while trying administrator admin: error code  302
```

**An√°lise Detalhada:**
- Medusa conseguiu conectar na porta correta
- Recebeu resposta 302 (Redirect) do servidor
- N√£o conseguiu processar o redirecionamento
- Falha na detec√ß√£o do sinal "Login failed"

### Terceira Tentativa - Ajuste na Detec√ß√£o

**Comando com Debug Ativado:**
```bash
medusa -h 127.0.0.1 -U usernames.txt -P passwords.txt -M web-form \
  -m FORM:"/login.php" \
  -m DENY-SIGNAL:"302 Found" \
  -m FORM-DATA:"post?username=&password=&Login=Login" \
  -n 42001 \
  -v 6
```

**Resultado com Verbose:**
```
DEBUG MODULE: [web-form.mod] Sending Web Form Authentication (POST).
DEBUG: Data sent: POST //login.php HTTP/1.0
Host: 127.0.0.1:42001
User-Agent: I'm not Mozilla, I'm Ming Mong
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 49

username=administrator&password=admin&Login=Login

DEBUG MODULE: [web-form.mod] Retrieving server response.
DEBUG: Data received (485): HTTP/1.1 302 Found
Server: nginx/1.28.0
Location: login.php
Set-Cookie: PHPSESSID=53117d204cb5a239b5c6bc199c5e589f
```

**Problema Identificado:**  
- Servidor respondia com 302 Found e Location: login.php  
- Medusa n√£o seguia redirecionamentos  
- Nunca via a p√°gina com "Login failed" (essencial para automa√ß√£o do brute force com Medusa)  
- Imposs√≠vel detectar sucesso/falha corretamente  

### An√°lise das Limita√ß√µes do Medusa

**Problemas Encontrados:**
1. **N√£o mant√©m sess√£o**: Cada requisi√ß√£o era independente
2. **N√£o segue redirecionamentos**: Perdia a resposta real do servidor
3. **N√£o extrai tokens din√¢micos**: Usava o mesmo token em todas as tentativas
4. **User-Agent fixo**: F√°cil de identificar e bloquear

**Comando de Teste com cURL para Compara√ß√£o:**
```bash
# Simulando o que o Medusa enviava
curl -X POST http://127.0.0.1:42001/login.php \
  -H "User-Agent: I'm not Mozilla, I'm Ming Mong" \
  -d "username=administrator&password=admin&Login=Login" \
  -s -I
```

## 6. An√°lise do C√≥digo-Fonte

### Localiza√ß√£o do Arquivo de Login

```bash
# Encontrando o arquivo login.php
sudo find / -name "login.php" 2>/dev/null | grep dvwa

# Resultado: /usr/share/dvwa/login.php
```

### An√°lise da Implementa√ß√£o CSRF

**Trecho Relevante do C√≥digo:**
```php
<?php
// ... c√≥digo anterior ...

if( isset( $_POST[ 'Login' ] ) ) {
    // Anti-CSRF
    if (array_key_exists ("session_token", $_SESSION)) {
        $session_token = $_SESSION[ 'session_token' ];
    } else {
        $session_token = "";
    }

    checkToken( $_REQUEST[ 'user_token' ], $session_token, 'login.php' );

    // ... processamento do login ...
}

// ... c√≥digo posterior ...

// Anti-CSRF
generateSessionToken();

// ... renderiza√ß√£o do formul√°rio ...
echo tokenField();
?>
```

### Estrutura de Prote√ß√£o Identificada

**1. Gera√ß√£o do Token:**
```php
generateSessionToken(); // Gera novo token a cada carregamento
```

**2. Inclus√£o no Formul√°rio:**
```php
echo tokenField(); // Output: <input type='hidden' name='user_token' value='TOKEN_AQUI' />
```

**3. Valida√ß√£o no Submit:**
```php
checkToken($_REQUEST['user_token'], $session_token, 'login.php');
// Retorna erro se tokens n√£o coincidirem
```

### Modifica√ß√£o para Testes Controlados

**Antes da Modifica√ß√£o:**
```php
checkToken( $_REQUEST[ 'user_token' ], $session_token, 'login.php' );
```

**Ap√≥s Modifica√ß√£o:**
```php
// checkToken( $_REQUEST[ 'user_token' ], $session_token, 'login.php' );
```

**Comando para Modifica√ß√£o:**
```bash
sudo nano /usr/share/dvwa/login.php
# Localizar linha com checkToken e comentar
```

### An√°lise do Mecanismo de Token

**Como os Tokens Funcionam:**
- **Gera√ß√£o**: `generateSessionToken()` cria token √∫nico
- **Armazenamento**: Salvo em `$_SESSION['session_token']`
- **Valida√ß√£o**: `checkToken()` compara token do form com token da sess√£o
- **Rotatividade**: Novo token a cada requisi√ß√£o

**Impacto nos Testes:**
- Cada tentativa do Medusa usava token diferente
- Sem manuten√ß√£o de sess√£o, tokens nunca coincidiam
- Todas as valida√ß√µes falhavam, mesmo com credenciais corretas

## 7. Resultados (`antes e depois` de entender como desativar a valida√ß√£o do CSRF)

#### Esses resultados foram conquistados ap√≥s todas as an√°lises das ferramentas e dos sistemas requeridos (e ensinados pela DIO) no desafio. As an√°lises est√£o um pouco mais pra cima dessa parte.

- **1. A ferramenta Medusa** mostrava `[SUCCESS]` em **todos** os logins e senhas tentadas nos ataques, o que n√£o era real.
  - Os resultados estavam estranhos - todos usernames e senhas que eu criava apareciam como "SUCCESS", indicando que eram logins v√°lidos para acessar o sistema web DVWA. 
  - De imediato desconfiei, e a partir desses resultados estranhos comecei uma an√°lise detalhada (era n√≠tido que a ferramenta n√£o estava funcionando direito).
  - Comecei a coletar, guardar e organizar as evid√™ncias relacionadas aos resultados estranhos da ferramenta Medusa.

- **2. A ferramenta Hydra** (que tamb√©m funciona igual a Medusa, fazendo ataques de brute force), tamb√©m mostrava que todas as palavras (wordlists) testadas eram v√°lidas como logins verdadeiros.
  - Testar dois ou tr√™s logins comprovavam que n√£o eram v√°lidos e que as ferramentas n√£o estavam mostrando resultados reais.
  - Ou seja, eram resultados **falsos-positivos**.

**Imagem abaixo**: ferramenta Hydra mostrando que todos os usernames e senhas s√£o verdadeiros para acessar o sistema web DVWA.   

![falsopositivodahydra](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/blob/main/Desafio_DVWA/images/hydra1.png) 

### An√°lise do Comportamento do Hydra

**Problemas Identificados:**
- Hydra tamb√©m n√£o mantinha estado de sess√£o
- Cada tentativa recebia token CSRF diferente
- Valida√ß√£o sempre falhava por token inv√°lido
- Mesmo com credenciais corretas, o acesso era bloqueado

### Teste Ap√≥s Desativar Valida√ß√£o CSRF

**Ap√≥s comentar a linha do `checkToken()` no c√≥digo login.php do DVWA, executei o comando da Hydra novamente:**  
  - Primeiro testei com tokens diferentes, resultado: Funcionou
  - Depois testei sem token, resultado: Funcionou tamb√©m
  - Resumo da Hydra: ap√≥s desativar o `checkToken()` a Hydra conseguiu fazer o ataque BruteForce
  - Resumo da Medusa: n√£o conseguiu fazer o ataque de BruteForce mesmo com o `checkToken()` desativado

```bash
hydra -L username.txt -P passwords.txt 127.0.0.1 http-post-form \
  "/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed" \
  -vV -s 42001
```
  
- Mesmo desativando a valida√ß√£o de Token (checkToken), o DVWA ainda continuava a gerar tokens.     
- A ferramenta Hydra conseguiu funcionar corretamente mesmo a gera√ß√£o de tokens, por√©m a Medusa n√£o conseguiu.    
- Depois desativei algumas outras partes do c√≥digo para n√£o gerar os Tokens mas mesmo assim a Medusa n√£o conseguiu realizar com sucesso o ataque de Brute Force no formul√°rio web da DVWA.    
- N√£o vou colocar todos os testes porque n√£o funcionaram, pois todos os n√≠veis de dificuldade do DVWA tem a gera√ß√£o de token, tanto o low, at√© o Impossible.    
- Para a Medusa funcionar, teria que remover a gera√ß√£o de Tokens em cada um dos n√≠veis, n√£o s√≥ no login.php.    
- Como a Hydra funcionou e a j√° era esperado que a Medusa n√£o funcion√°ria, pois n√£o tem como gerenciar Brute Force com Tokens na Medusa, partir para a conclus√£o do desafio.    
- A ferramenta Medusa funcionou normalmente atacando o Metasploitable, como ftp, que exige s√≥ uma linha de comando para concluir o ataque com sucesso.    


**Imagem 1:** colocando "//" na linha do `checkToken` para desativar a valida√ß√£o do CSRF no DVWA (script: login.php)   

![](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/blob/main/Desafio_DVWA/images/loginphpcomment.png)   

- **Teste 1**: Mesmo desativando o checkToken, os tokens ainda eram gerados, ent√£o tentei o BruteForce com o mesmo token da sess√£o.   
**Image 2:** Resultado ap√≥s comentar // na linha do checkToken, com Token no comando de ataque diferente do token da sess√£o = Funcionou
  
![](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/blob/main/Desafio_DVWA/images/hydrasuccess.png) 

- **Teste 2**: Minha l√≥gica continuou no que deu certo: "Se o ataque funcionou com tokens deiferentes pois os tokens n√£o s√£o validados (desativamos comentando com "//"), ent√£o n√£o precisa dos n√∫meros e letras dos tokens no comando do ataque."
    - Ent√£o removi o token do comando de ataque da Hydra, comprovando que minha l√≥gica estava certa: N√£o precisa de token no ataque `SE` n√£o existe a valida√ß√£o dos mesmos.
    - A l√≥gica continuou nos tokens, "se a Hydra funcionou, vou testar se a Medusa tamb√©m funciona agora que os tokens n√£o s√£o validados".
         - Mas n√£o, a Medusa n√£o conseguiu fazer o ataque com sucesso, pois mesmo que n√£o exista a valida√ß√£o dos tokens, eles `AINDA` estavam sendo gerados.
         - Conclus√£o:
           -   A ferramenta Medusa n√£o consegue lidar com tokens em ataques de brute force sozinha.
           -   J√° a Hydra consegue lidar com tokens gerados, sozinha, mas n√£o consegue lidar com a valida√ß√£o dos tokens (precisa de outras ferramentas).  
    
      
  
**Image 3:** Sucesso ap√≥s rodar a Hydra sem expecificar um token no comando de ataque do Terminal (pois o checkToken estava desativado no login.php)  
![](https://github.com/ThiagoMaria-SecurityIT/Bootcamp_DIO_e_Santander-Ciberseguran-a_2025/blob/main/Desafio_DVWA/images/hydrasucessoweb.png)



### Compara√ß√£o Entre Ferramentas

| Aspecto | Medusa | Hydra |
|---------|---------|--------|
| **Manuten√ß√£o de Sess√£o** | ‚ùå N√£o mant√©m | ‚ùå N√£o mant√©m |
| **Tokens CSRF** | ‚ùå N√£o manipula | ‚ùå N√£o manipula |
| **Redirecionamentos** | ‚ùå N√£o segue | ‚úÖ Segue |
| **Detec√ß√£o de Sucesso** | ‚ùå Limitada | ‚úÖ Flex√≠vel |
| **Velocidade** | ‚ö° Muito r√°pida | üê¢ Mais lenta |

### Testes com M√∫ltiplos Usu√°rios

**Comandos Hydra com Lista de Usu√°rios:**
```bash
hydra -L usernames.txt -P passwords.txt 127.0.0.1 http-post-form \
  "/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed" \
  -vV -s 42001
```

```bash
#Comando em uma linha
hydra -L usernames.txt -P passwords.txt 127.0.0.1 http-post-form "/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed" -vV -s 42001
```

**Resultado:**
- **Sucesso**: `admin:password`
- **Falha**: Todos os outros usu√°rios
- **Tempo**: Aproximadamente 30 segundos para 56 combina√ß√µes

---

## 8. An√°lise Detalhada dos Resultados

### Compara√ß√£o T√©cnica Aprofundada

#### Comportamento com CSRF Ativo

**Medusa com CSRF Ativo:**
```bash
# Comando executado
medusa -h 127.0.0.1 -U usernames.txt -P passwords.txt -M web-form \
  -m FORM:"/login.php" -m DENY-SIGNAL:"Login failed" \
  -m FORM-DATA:"post?username=&password=&Login=Login" -n 42001 -v 4

# Comportamento observado
- Conex√£o estabelecida com sucesso
- Resposta HTTP 302 recebida
- N√£o consegue detectar "Login failed" (n√£o segue redirect)
- Falha em todas as tentativas
- Taxa de sucesso: 0%
```

**Hydra com CSRF Ativo:**
```bash
# Comando executado
hydra -L usernames.txt -P passwords.txt 127.0.0.1 http-post-form "/login.php:username=^USER^&password=^PASS^&Login=Login&user_token=ccdd7f329362a78cc6bed4122bf0b5e5:F=Login failed" -vV -s 42001

# Comportamento observado
- Segue redirecionamentos
- Detecta p√°gina de login ap√≥s redirect
- Consegue ver "Login failed" 
- Mas valida√ß√£o CSRF bloqueia acesso
- Taxa de sucesso: 0%
```

#### Comportamento com CSRF Desativado

**Medusa com CSRF Desativado:**
```bash
# Mesmo comportamento - ainda falha
- Continua sem seguir redirects
- N√£o mant√©m sess√£o entre tentativas
- Taxa de sucesso: 0%
```

**Hydra com CSRF Desativado:**
```bash
# Comando executado
hydra -L usernames.txt -P passwords.txt 127.0.0.1 http-post-form "/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed" -vV -s 42001

# Comportamento radicalmente diferente
- Segue redirecionamentos normalmente
- Detecta corretamente sucesso/falha
- Encontra credenciais admin:password
- Taxa de sucesso: 100% para credenciais conhecidas
```

### An√°lise de Performance

**Tempos de Execu√ß√£o:**
- **Medusa**: ~5 segundos (falha r√°pida)
- **Hydra (CSRF ativo)**: ~20 segundos (tentativas completas mas sem sucesso)
- **Hydra (CSRF desativado)**: ~30 segundos (sucesso na 4¬™ tentativa)

**Efici√™ncia de Detec√ß√£o:**
- **Medusa**: N√£o detecta nenhum cen√°rio corretamente
- **Hydra**: Detecta todos os cen√°rios quando CSRF est√° desativado

## 9. Conclus√µes T√©cnicas

### Efic√°cia do CSRF como Mecanismo de Defesa

**Prote√ß√£o Comprovada:**
- ‚úÖ Bloqueia ferramentas automatizadas simples
- ‚úÖ Requer manipula√ß√£o manual para bypass
- ‚úÖ Implementa√ß√£o relativamente simples
- ‚úÖ Impacto m√≠nimo em usu√°rios leg√≠timos

**Estat√≠sticas de Efic√°cia:**
- **Medusa**: 100% de bloqueio
- **Hydra**: 100% de bloqueio (com valida√ß√£o ativa)
- **Scripts simples**: 100% de bloqueio
- **Ataques manuais**: Requer conhecimento t√©cnico avan√ßado

### Limita√ß√µes das Ferramentas de Brute Force

**Problemas Comuns Identificados:**

1. **Falta de Manuten√ß√£o de Estado:**
```python
# Exemplo do problema
# Ferramentas fazem:
request1 = GET /login.php ‚Üí token_ABC
request2 = POST /login.php (com token_ABC) ‚Üí token j√° expirou

# Deveriam fazer:
session = requests.Session()
request1 = session.get(/login.php) ‚Üí token_ABC  
request2 = session.post(/login.php, token_ABC) ‚Üí token ainda v√°lido
```

2. **Processamento Insuficiente de JavaScript:**
- Muitas aplica√ß√µes modernas usam JS para manipular tokens
- Ferramentas CLI n√£o executam JavaScript
- Tokens din√¢micos via JS s√£o completamente invis√≠veis

3. **Gest√£o Primitiva de Cookies:**
```bash
# Gest√£o b√°sica (ferramentas atuais)
curl -b cookies.txt -c cookies.txt

# Gest√£o ideal necess√°ria
- Manter sess√µes separadas por usu√°rio
- Renovar cookies de sess√£o automaticamente
- Lidar com m√∫ltiplos dom√≠nios/paths
```

## 10. Li√ß√µes Aprendidas como Profissional de Seguran√ßa

**Habilidades Desenvolvidas:**

1. **An√°lise Forense de Aplica√ß√µes Web:**
```bash
# T√©cnicas que funcionaram bem
curl -s URL | grep -E "token|csrf|hidden"  # Identifica√ß√£o r√°pida
curl -I URL # An√°lise de headers
curl -v URL # Debug detalhado
```

2. **Metodologia de Testes Estruturada:**
```
Minha Abordagem:
1. Reconhecimento ‚Üí An√°lise do formul√°rio
2. Diagn√≥stico ‚Üí Identifica√ß√£o de prote√ß√µes  
3. Experimenta√ß√£o ‚Üí Testes com diferentes ferramentas
4. Documenta√ß√£o ‚Üí Registro de resultados
5. An√°lise ‚Üí Interpreta√ß√£o e aprendizado
```

3. **Pensamento Adaptativo:**
- Quando Medusa falhou, n√£o desisti
- Usei cURL para entender o problema
- Testei alternativas (Hydra)
- Adaptei a abordagem baseado nos resultados

**Compet√™ncias T√©cnicas Comprovadas:**

- **An√°lise de C√≥digo-Fonte**: Capacidade de ler e entender implementa√ß√µes de seguran√ßa
- **Diagn√≥stico de Problemas**: Habilidade para identificar causas raiz de falhas
- **Conhecimento Multi-Ferramenta**: Versatilidade com diferentes tecnologias
- **Documenta√ß√£o T√©cnica**: Clareza na comunica√ß√£o de descobertas complexas

## 11. Recomenda√ß√µes de Mitiga√ß√£o

### Para Desenvolvedores

**Implementa√ß√£o de CSRF (Exemplo Python/Flask):**
```python
from flask import Flask, session, request, render_template_string
import secrets
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)

def generate_csrf_token():
    """Gera e armazena token CSRF na sess√£o"""
    if 'csrf_token' not in session:
        session['csrf_token'] = secrets.token_urlsafe(32)
    return session['csrf_token']

def validate_csrf_token():
    """Valida token CSRF para requisi√ß√µes POST"""
    if request.method == "POST":
        token = session.get('csrf_token')
        form_token = request.form.get('csrf_token')
        if not token or token != form_token:
            return False
    return True

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        if not validate_csrf_token():
            return "Erro de seguran√ßa CSRF", 400
            
        # Processar login normalmente
        username = request.form['username']
        password = request.form['password']
        # ... valida√ß√£o de credenciais
        
    # Renderizar formul√°rio com token
    return render_template_string('''
        <form method="POST">
            <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
            <input type="text" name="username" placeholder="Usu√°rio">
            <input type="password" name="password" placeholder="Senha">
            <button type="submit">Login</button>
        </form>
    ''', csrf_token=generate_csrf_token())
```

**Camadas Adicionais de Seguran√ßa Recomendadas:**

1. **Rate Limiting:**
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(app, key_func=get_remote_address)

@app.route('/login', methods=['POST'])
@limiter.limit("5 per minute")  # 5 tentativas por minuto por IP
def login_post():
    # ... l√≥gica de login
```

2. **Prote√ß√£o Contra Credenciais Comuns:**
```python
COMMON_PASSWORDS = {'password', '123456', 'admin', 'letmein'}

def is_common_password(password):
    return password.lower() in COMMON_PASSWORDS
```

### Para Administradores de Sistemas

**Configura√ß√µes de Servidor Web (Exemplo Nginx):**
```nginx
# Rate limiting no n√≠vel do servidor
http {
    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;
    
    server {
        location /login.php {
            limit_req zone=login burst=10 nodelay;
            # ... outras configura√ß√µes
        }
    }
}
```

**Monitoramento e Detec√ß√£o:**
```bash
# Exemplo de monitoramento com fail2ban
# /etc/fail2ban/jail.d/web-login.conf
[web-login]
enabled = true
port = http,https
filter = web-login
logpath = /var/log/nginx/access.log
maxretry = 5
bantime = 3600
```

### Para Equipes de Seguran√ßa

**Testes Recomendados:**
```bash
# Script de teste CSRF b√°sico
#!/bin/bash
echo "=== Teste de Prote√ß√£o CSRF ==="

# Teste 1: Requisi√ß√£o sem token
echo "Teste 1 - Sem token CSRF:"
curl -X POST $URL -d "username=test&password=test" -s -w "Status: %{http_code}\n"

# Teste 2: Requisi√ß√£o com token inv√°lido  
echo "Teste 2 - Token CSRF inv√°lido:"
curl -X POST $URL -d "username=test&password=test&csrf_token=invalid" -s -w "Status: %{http_code}\n"

# Teste 3: Verificar se token est√° presente
echo "Teste 3 - Verificar presen√ßa de token:"
curl -s $URL | grep -q "csrf_token" && echo "‚úÖ CSRF detectado" || echo "‚ùå CSRF n√£o detectado"
```

## Valida√ß√£o do Aprendizado

### Compet√™ncias Demonstradas

**Habilidades T√©cnicas:**
- ‚úÖ An√°lise de aplica√ß√µes web
- ‚úÖ Uso de ferramentas de brute force
- ‚úÖ Diagn√≥stico de mecanismos de seguran√ßa
- ‚úÖ Manipula√ß√£o de sess√µes HTTP
- ‚úÖ An√°lise de c√≥digo-fonte

**Habilidades Metodol√≥gicas:**
- ‚úÖ Abordagem cient√≠fica para testes
- ‚úÖ Documenta√ß√£o t√©cnica detalhada
- ‚úÖ An√°lise cr√≠tica de resultados
- ‚úÖ Adapta√ß√£o estrat√©gica
- ‚úÖ Comunica√ß√£o de descobertas

**Habilidades de Seguran√ßa:**
- ‚úÖ Compreens√£o de vetores de ataque
- ‚úÖ Conhecimento de controles defensivos
- ‚úÖ Avalia√ß√£o de efic√°cia de seguran√ßa
- ‚úÖ Desenvolvimento de recomenda√ß√µes
- ‚úÖ Consci√™ncia √©tica

### Aplica√ß√£o Pr√°tica do Conhecimento

**Como Este Conhecimento se Aplica no Mundo Real:**

1. **Testes de Penetra√ß√£o:**
- Agora entendo por que alguns ataques automatizados falham
- Posso explicar aos clientes a efic√°cia de suas prote√ß√µes
- Sei quando investir tempo em ataques manuais vs automatizados

2. **Desenvolvimento Seguro:**
- Posso implementar prote√ß√µes CSRF eficazes
- Compreendo a import√¢ncia da seguran√ßa em camadas
- Sei balancear seguran√ßa e usabilidade

3. **Arquitetura de Seguran√ßa:**
- Posso recomendar controles baseado em efic√°cia comprovada
- Entendo as limita√ß√µes de diferentes abordagens
- Posso priorizar implementa√ß√µes baseado em risco

## 12. Pr√≥ximos Passos e Expans√£o

### Melhorias para Este Projeto

**Script de Automa√ß√£o:**
```python
#!/usr/bin/env python3
"""
Script avan√ßado para teste de brute force com manipula√ß√£o de CSRF
"""
import requests
from bs4 import BeautifulSoup
import sys

class AdvancedBruteForcer:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        
    def extract_csrf_token(self, html_content):
        """Extrai token CSRF do HTML"""
        soup = BeautifulSoup(html_content, 'html.parser')
        token_input = soup.find('input', {'name': 'user_token'})
        return token_input['value'] if token_input else None
    
    def attempt_login(self, username, password):
        """Tenta login mantendo sess√£o e tokens"""
        # Primeiro, obt√©m a p√°gina de login
        response = self.session.get(self.target_url)
        csrf_token = self.extract_csrf_token(response.text)
        
        if not csrf_token:
            print("‚ùå Token CSRF n√£o encontrado")
            return False
            
        # Prepara dados do formul√°rio
        login_data = {
            'username': username,
            'password': password,
            'Login': 'Login',
            'user_token': csrf_token
        }
        
        # Envia requisi√ß√£o de login
        response = self.session.post(self.target_url, data=login_data)
        
        # Verifica se login foi bem-sucedido
        return "Login failed" not in response.text

# Implementa√ß√£o futura...
```

### Expans√µes Poss√≠veis

1. **Testes com Outras Ferramentas:**
   - Burp Suite Intruder
   - OWASP ZAP
   - Patator
   - Ncrack

2. **Cen√°rios Adicionais:**
   - Prote√ß√µes com CAPTCHA
   - Autentica√ß√£o multi-fator
   - Block por IP
   - An√°lise de comportamento

3. **Integra√ß√£o com CI/CD:**
   - Testes automatizados de seguran√ßa
   - Scan de vulnerabilidades
   - Relat√≥rios autom√°ticos

## 13. Conclus√£o Final

Este projeto demonstrou de forma pr√°tica e mensur√°vel que:

### Prote√ß√µes CSRF s√£o eficazes mas podem ser contornadas   
- **Efic√°cia comprovada** contra ferramentas automatizadas tradicionais (Medusa e Hydra)  
- **Implementa√ß√£o simples** com grande impacto em prote√ß√£o
- **M√≠nimo impacto** na experi√™ncia do usu√°rio leg√≠timo (n√£o consome muitos recursos do navegador ou do computador)  

### As Ferramentas Tem Limita√ß√µes Significativas
- **Medusa**: Inadequado para aplica√ß√µes com CSRF
- **Hydra**: Limitado sem manipula√ß√£o manual
- **Automa√ß√£o**: Requer scripts customizados para efic√°cia
- **CSRF n√£o √© 100% de garantia de prote√ß√£o:** No Kali tem outras ferramentas que contornam o CSRF, esse projeto simples √© somente para Brute Force com Medusa e Hydra e n√£o envolve outras ferramentas do Kali.  

### O Conhecimento T√©cnico √© Fundamental
- **Ferramentas s√£o meios, n√£o fins**
- **An√°lise manual complementa automa√ß√£o**
- **Documenta√ß√£o acelera o aprendizado**

### Valor para Minha Carreira
Como profissional de seguran√ßa, este projeto:
- **Validou conhecimentos** te√≥ricos na pr√°tica
- **Expandiu meu toolkit** t√©cnico
- **Refor√ßou a import√¢ncia** da metodologia
- **Demonstrou compet√™ncia** em documenta√ß√£o t√©cnica

**Pr√≥ximo N√≠vel:** O desafio me motivou a explorar desenvolvimento de ferramentas customizadas e testes mais avan√ßados, solidificando meu caminho como especialista em seguran√ßa ofensiva.

---

**Autor:** Thiago Maria   
**Data:** Outubro de 2025   
**Desafio:** Santander Ciberseguran√ßa 2025 em parceria com a DIO     

---

### Tutorial r√°pido e secreto (n√≠vel `Impossible` ou qualquer outro):

1. Instale o DVWA  
```bash
# Atualiza√ß√£o do sistema
sudo apt update

# Instala√ß√£o do DVWA
sudo apt install dvwa

# Inicializa√ß√£o do servi√ßo
dvwa-start
```
2. Entre no login.php do DVWA  

```
sudo nano /usr/share/dvwa/login.php
```
3. Comente com `//` para desativar o checkToken  
```
// checkToken( $_REQUEST[ 'user_token' ], $session_token, 'login.php' );
```
4. Rode a Hydra
```
hydra -L usernames.txt -P passwords.txt 127.0.0.1 http-post-form "/login.php:username=^USER^&password=^PASS^&Login=Login:F=Login failed" -vV -s 42001
```

*"A seguran√ßa n√£o √© um produto, mas um processo cont√≠nuo de aprendizado e adapta√ß√£o."*

---

## 14. About Me & Contact

**Thiago Maria - From Brazil to the World üåé**  
*Senior Information Security Professional | Security Risk & Compliance Specialist | AI Security Researcher | Software Developer | Post-Quantum Cryptography Enthusiast*

My passion for programming and my professional background in security analysis led me to create this GitHub account to share my knowledge of security information, cybersecurity, Python, and AI development practices. My work primarily focuses on prioritizing security in organizations while ensuring usability and productivity.

Let's Connect:  

üëáüèΩ Click on the badges below:  

[![LinkedIn](https://img.shields.io/badge/LinkedIn-Connect-blue)](https://www.linkedin.com/in/thiago-cequeira-99202239/)  
[![Hugging Face](https://img.shields.io/badge/ü§óHugging_Face-AI_projects-yellow)](https://huggingface.co/ThiSecur)  
   


